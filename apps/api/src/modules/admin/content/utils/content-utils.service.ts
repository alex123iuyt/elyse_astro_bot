import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { ContentType, PublishStatus } from '@prisma/client';

@Injectable()
export class ContentUtilsService {
  constructor(private readonly prisma: PrismaService) {}

  async copyYesterdayContent(): Promise<{ copied: number; errors: string[] }> {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split('T')[0];

    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];

    const errors: string[] = [];
    let copied = 0;

    try {
      // Находим все ежедневные типы контента за вчера
      const yesterdayContent = await this.prisma.content.findMany({
        where: {
          type: {
            in: [
              ContentType.DAILY_FORECAST,
              ContentType.DAILY_ADVICE_HOME,
              ContentType.DOMAIN_FORECAST,
              ContentType.MOON_CALENDAR,
            ],
          },
          effectiveDate: yesterdayStr,
          status: PublishStatus.PUBLISHED,
        },
      });

      // Копируем каждый элемент на сегодня
      for (const content of yesterdayContent) {
        try {
          await this.prisma.content.create({
            data: {
              ...content,
              id: undefined, // Генерируем новый ID
              effectiveDate: todayStr,
              status: PublishStatus.DRAFT,
              version: 1,
              createdAt: new Date(),
              updatedAt: new Date(),
              meta: {
                ...content.meta,
                source: 'copy-yesterday',
                originalId: content.id,
                copiedAt: new Date().toISOString(),
              },
            },
          });
          copied++;
        } catch (error) {
          errors.push(`Ошибка копирования ${content.id}: ${error.message}`);
        }
      }
    } catch (error) {
      errors.push(`Общая ошибка: ${error.message}`);
    }

    return { copied, errors };
  }

  async generateTodayContent(): Promise<{ generated: number; errors: string[] }> {
    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];
    const errors: string[] = [];
    let generated = 0;

    try {
      // Генерируем контент для всех знаков зодиака
      const zodiacSigns = [
        'ARIES', 'TAURUS', 'GEMINI', 'CANCER', 'LEO', 'VIRGO',
        'LIBRA', 'SCORPIO', 'SAGITTARIUS', 'CAPRICORN', 'AQUARIUS', 'PISCES'
      ];

      for (const sign of zodiacSigns) {
        try {
          // Проверяем, есть ли уже контент на сегодня для этого знака
          const existing = await this.prisma.content.findFirst({
            where: {
              type: ContentType.DAILY_FORECAST,
              effectiveDate: todayStr,
              sign: sign as any,
            },
          });

          if (!existing) {
            await this.prisma.content.create({
              data: {
                type: ContentType.DAILY_FORECAST,
                title: `Ежедневный прогноз для ${sign} на ${todayStr}`,
                effectiveDate: todayStr,
                sign: sign as any,
                status: PublishStatus.DRAFT,
                locale: 'ru',
                version: 1,
                meta: {
                  generatedAt: new Date().toISOString(),
                  sign,
                  date: todayStr,
                  autoGenerated: true,
                },
              },
            });
            generated++;
          }
        } catch (error) {
          errors.push(`Ошибка генерации для ${sign}: ${error.message}`);
        }
      }
    } catch (error) {
      errors.push(`Общая ошибка генерации: ${error.message}`);
    }

    return { generated, errors };
  }
}






